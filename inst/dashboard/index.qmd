---
title: "MDL R01 GABM Participant Dashboard"
---

```{r}
#| echo: false
#| output: asis

# Define null coalescing operator
`%||%` <- function(x, y) if (is.null(x)) y else x

cat(paste0("**Last updated:** ", abmdash::get_central_time(), "\n\n"))
```

## Row {.tabset}

### Participant Tracking

#### Column {width=50%}

::: {.card title="Upcoming Participant Schedule"}

```{r}
# Get today's calendar events from Google Calendar
calendar_events <- tryCatch({
  # Test Google Calendar API connection
  service_account_json <- Sys.getenv("GOOGLE_SERVICE_ACCOUNT_JSON")
  
  if (service_account_json == "" || is.na(service_account_json)) {
    # Show message when Google Calendar not configured
    data.frame(
      Time = "Not configured",
      Event = "GOOGLE_SERVICE_ACCOUNT_JSON not set",
      stringsAsFactors = FALSE
    )
  } else {
    # Get next week's events (today through next 7 days)
    today_start <- paste0(Sys.Date(), "T00:00:00Z")
    next_week_end <- paste0(Sys.Date() + 7, "T23:59:59Z")
    
    # Use the specific Calendar ID for "Research Team Schedule"
    events <- abmdash::get_calendar_events(
      calendar_id = "ff5b00ef944953433c805960d64adae47a456ee0d2515410cc648f65bafc2635@group.calendar.google.com",
      time_min = today_start,
      time_max = next_week_end,
      max_results = 100
    )
    
    # Debug: Check what we're getting
    debug_info <- paste(
      "API Response - Items count:", if("items" %in% names(events)) length(events$items) else "No items field",
      "| Time range:", today_start, "to", next_week_end,
      "| Today:", Sys.Date(), "| Next week end:", Sys.Date() + 7
    )
    
    # Format events for display
    if (is.list(events) && "items" %in% names(events) && length(events$items) > 0) {
      # Filter events to only include those with "UT Attention Bias Modification" in the title
      filtered_events <- Filter(function(event) {
        summary <- event$summary %||% ""
        grepl("UT Attention Bias Modification", summary, ignore.case = TRUE)
      }, events$items)

      if (length(filtered_events) > 0) {
        # Build data frame directly - simpler approach
        Time <- character(length(filtered_events))
        Event <- character(length(filtered_events))
        Clinician <- character(length(filtered_events))
        Session <- character(length(filtered_events))
        Participant_Status <- character(length(filtered_events))
        SortDate <- as.POSIXct(rep(NA, length(filtered_events)))
        IsToday <- logical(length(filtered_events))

        # Hard-coded clinician mapping
        clinician_map <- c(
          "arieltseng@utexas.edu" = "Ariel",
          "alevihncoon@utexas.edu" = "Andrew",
          "rachelweisenburger@utexas.edu" = "Rachel"
        )

        for (i in seq_along(filtered_events)) {
          event <- filtered_events[[i]]

          # Get event summary
          summary <- if (!is.null(event$summary)) event$summary else "No title"

          # Extract clinician from attendees and get participant acceptance status
          clinician_name <- NA_character_
          participant_status <- ""

          if (!is.null(event$attendees) && length(event$attendees) > 0) {
            for (attendee in event$attendees) {
              if (!is.null(attendee$email)) {
                if (attendee$email %in% names(clinician_map)) {
                  # This is the clinician
                  clinician_name <- clinician_map[[attendee$email]]
                } else {
                  # This is the participant
                  participant_status <- if (!is.null(attendee$responseStatus)) {
                    switch(attendee$responseStatus,
                      "accepted" = "Yes",
                      "needsAction" = "Pending",
                      "declined" = "No",
                      "tentative" = "Maybe",
                      attendee$responseStatus
                    )
                  } else {
                    ""
                  }
                }
              }
            }
          }

          Clinician[i] <- if (!is.na(clinician_name)) clinician_name else "TBD"
          Participant_Status[i] <- participant_status

          # Extract session type from description
          session_type <- "Screening"  # Default
          if (!is.null(event$description)) {
            # Look for "Which Session Event?:" in the description
            match <- regmatches(event$description, regexpr("Which Session Event\\?:\\s*([^<\n]+)", event$description, perl = TRUE))
            if (length(match) > 0) {
              # Extract the text after "Which Session Event?:"
              session_text <- sub("Which Session Event\\?:\\s*", "", match, perl = TRUE)
              session_text <- trimws(session_text)
              if (nchar(session_text) > 0) {
                session_type <- session_text
              }
            }
          }
          Session[i] <- session_type

          # Extract time and date from start datetime
          if (!is.null(event$start$dateTime)) {
            # Parse datetime from Google Calendar (already in correct timezone)
            dt <- as.POSIXct(event$start$dateTime, format = "%Y-%m-%dT%H:%M:%S")

            if (is.na(dt)) {
              # Try without Z suffix
              dt <- as.POSIXct(gsub("Z$", "", event$start$dateTime))
            }

            if (!is.na(dt)) {
              # Get today's date in Central Time for comparison
              today_central <- as.Date(format(Sys.time(), tz = "America/Chicago"))
              event_date <- as.Date(dt)
              days_diff <- as.numeric(event_date - today_central)

              if (days_diff == 0) {
                Time[i] <- paste("Today", format(dt, "%I:%M %p"))
                IsToday[i] <- TRUE
              } else if (days_diff == 1) {
                Time[i] <- paste("Tomorrow", format(dt, "%I:%M %p"))
                IsToday[i] <- FALSE
              } else {
                day_name <- format(event_date, "%a")
                Time[i] <- paste(day_name, format(event_date, "%m/%d"), format(dt, "%I:%M %p"))
                IsToday[i] <- FALSE
              }

              SortDate[i] <- dt
              Event[i] <- summary
            }
          } else if (!is.null(event$start$date)) {
            # All-day event
            event_date <- as.Date(event$start$date)

            if (!is.na(event_date)) {
              days_diff <- as.numeric(event_date - Sys.Date())

              if (days_diff == 0) {
                Time[i] <- "Today (All Day)"
                IsToday[i] <- TRUE
              } else if (days_diff == 1) {
                Time[i] <- "Tomorrow (All Day)"
                IsToday[i] <- FALSE
              } else {
                day_name <- format(event_date, "%a")
                Time[i] <- paste(day_name, format(event_date, "%m/%d"), "(All Day)")
                IsToday[i] <- FALSE
              }

              SortDate[i] <- as.POSIXct(paste(event_date, "00:00:00"), tz = "UTC")
              Event[i] <- summary
            }
          }
        }

        # Create data frame and remove any rows with NA SortDate
        events_df <- data.frame(
          Time = Time,
          Event = Event,
          Clinician = Clinician,
          Session = Session,
          Participant_Accepted = Participant_Status,
          SortDate = SortDate,
          IsToday = IsToday,
          stringsAsFactors = FALSE
        )

        # Remove rows where parsing failed
        events_df <- events_df[!is.na(events_df$SortDate), ]

        # Sort by date/time in chronological order
        events_df <- events_df[order(events_df$SortDate), ]
      } else {
        data.frame(
          Time = "No ABM events",
          Event = "No UT Attention Bias Modification events scheduled",
          Clinician = "",
          Session = "",
          Participant_Accepted = "",
          stringsAsFactors = FALSE
        )
      }
    } else {
      data.frame(
        Time = "Debug Info",
        Event = debug_info,
        Clinician = "",
        Session = "",
        Participant_Accepted = "",
        stringsAsFactors = FALSE
      )
    }
  }
}, error = function(e) {
  data.frame(
    Time = "Error",
    Event = paste("Full error:", e$message),
    Clinician = "",
    Session = "",
    Participant_Accepted = "",
    stringsAsFactors = FALSE
  )
})

# Display calendar events with highlighting for today's appointments
if ("IsToday" %in% names(calendar_events) && any(calendar_events$IsToday)) {
  # Create display table without internal columns
  display_events <- calendar_events[, c("Time", "Event", "Clinician", "Session", "Participant_Accepted")]

  # Create tinytable and highlight today's rows
  today_rows <- which(calendar_events$IsToday)
  display_events |>
    tinytable::tt(caption = "Upcoming Week's Schedule") |>
    tinytable::style_tt(i = today_rows, background = "#e3f2fd", bold = TRUE)
} else {
  # No today events or no IsToday column - display without highlighting
  if ("IsToday" %in% names(calendar_events)) {
    calendar_events[, c("Time", "Event", "Clinician", "Session", "Participant_Accepted")] |>
      tinytable::tt(caption = "Upcoming Week's Schedule")
  } else {
    calendar_events |>
      tinytable::tt(caption = "Upcoming Week's Schedule")
  }
}
```

:::

::: {.card title="Recent Eligible Participants (Check if Scheduled)"}

```{r}
# Get eligible participants from report 11942
eligible_participants <- tryCatch({
  token <- Sys.getenv("REDCAP_API_TOKEN")
  
  if (token == "" || is.na(token)) {
    # Show message when REDCap not configured
    data.frame(
      Status = "REDCAP_API_TOKEN not configured",
      Total_Records = 0,
      Eligible_Count = 0,
      stringsAsFactors = FALSE
    )
  } else {
    # Get eligible participants using our filtering function
    abmdash::get_eligible_participants()
  }
}, error = function(e) {
  data.frame(
    Status = paste("Error:", substr(e$message, 1, 50)),
    Total_Records = 0,
    Eligible_Count = 0,
    stringsAsFactors = FALSE
  )
})

# Display the results
if ("first_name" %in% names(eligible_participants)) {
  # We have actual participant data - rename columns and display
  display_data <- eligible_participants
  names(display_data) <- c("First Name", "Phone Number", "Screen Date", "Link to REDCap Record")

  display_data |>
    tinytable::tt(caption = "Eligible Participants (Past 30 Days)") |>
    tinytable::format_tt(
      j = "Link to REDCap Record",
      fn = function(x) paste0('<a href="', x, '" target="_blank">View Record</a>')
    )
} else {
  # We have summary data - display as is
  eligible_participants |>
    tinytable::tt(caption = "Eligible Participants Summary")
}
```

:::

#### Column {width=50%}

::: {.card title="Status of Follow-Up Surveys"}

```{r}
# Get upcoming follow-ups (Week 12, 16, 28)
upcoming_followups <- tryCatch({
  token <- Sys.getenv("REDCAP_API_TOKEN")
  
  if (token == "" || is.na(token)) {
    # Show sample data when REDCap not configured
    data.frame(
      record_id = c("1420", "1385", "1555", "1604"),
      follow_up_type = c("Week 12", "Week 16", "Week 12", "Week 28"),
      w4_completion_date = c("2024-06-01", "2024-05-15", "2024-06-03", "2024-01-15"),
      due_date = c("2024-07-27", "2024-08-07", "2024-07-29", "2024-07-22"),
      days_until_due = c(-3, 5, -1, 2),
      status = c("Overdue by 3 days", "Due in 5 days", "Overdue by 1 day", "Due in 2 days"),
      stringsAsFactors = FALSE
    )
  } else {
    # Get actual upcoming follow-ups (next 14 days)
    abmdash::get_upcoming_followups(days_ahead = 14)
  }
}, error = function(e) {
  cat("Follow-up tracking error:", e$message, "\n")
  data.frame(
    record_id = "ERROR",
    follow_up_type = "API Error",
    w4_completion_date = "",
    due_date = "",
    days_until_due = 0,
    status = paste("Error:", substr(e$message, 1, 20)),
    stringsAsFactors = FALSE
  )
})

# Display results
if (nrow(upcoming_followups) > 0) {
  # Update status messages to use "Send" instead of "Due" for future dates
  updated_status <- sapply(1:nrow(upcoming_followups), function(i) {
    days_until <- upcoming_followups$days_until_due[i]
    
    if (days_until < 0) {
      # Overdue - keep as is
      paste("Overdue by", abs(days_until), "days")
    } else if (days_until == 0) {
      # Due today - change to "Send Today"
      "Send Today"
    } else {
      # Future date - change to "Send in X days"
      paste("Send in", days_until, "days")
    }
  })
  
  # Format the display with colors for urgency
  display_table <- data.frame(
    "Participant" = upcoming_followups$record_id,
    "Follow Up" = upcoming_followups$follow_up_type,
    "Due Date" = format(as.Date(upcoming_followups$due_date), "%m/%d"),
    "Status" = updated_status,
    stringsAsFactors = FALSE
  )
  
  # Create tinytable with conditional formatting
  tt_table <- display_table |>
    tinytable::tt()
  
  # Add highlighting for overdue items
  if (any(grepl("Overdue", display_table$Status))) {
    overdue_rows <- which(grepl("Overdue", display_table$Status))
    tt_table <- tt_table |>
      tinytable::style_tt(i = overdue_rows, background = "#ffebee")
  }
  
  # Add highlighting for send today
  if (any(grepl("Send Today", display_table$Status))) {
    send_today_rows <- which(grepl("Send Today", display_table$Status))
    tt_table <- tt_table |>
      tinytable::style_tt(i = send_today_rows, background = "#fff3e0")
  }
  
  tt_table
} else {
  data.frame(Message = "No follow-ups due in the next 2 weeks") |>
    tinytable::tt()
}
```
:::

::: {.card title="Participant Issues"}

```{r}
# Check for recent participant issues
issues <- tryCatch({
  abmdash::check_participant_issues(days_back = 14, verbose = FALSE)
}, error = function(e) {
  list(
    has_recent = FALSE,
    recent_count = 0,
    error = TRUE,
    message = e$message
  )
})

# Display results
sheet_url <- "https://docs.google.com/spreadsheets/d/11FAAY4cUvqpW7QN7k-mcpOCx3WfrcA6GNeTXgBT1St8/edit#gid=2031348125"

if (!is.null(issues$error) && issues$error) {
  # Error occurred
  data.frame(
    Message = paste("Error checking issues:", substr(issues$message, 1, 50)),
    Action = sheet_url
  ) |>
    tinytable::tt() |>
    tinytable::format_tt(
      j = "Action",
      fn = function(x) paste0('<a href="', x, '" target="_blank">Check Issues Form</a>')
    )
} else if (issues$has_recent && issues$recent_count > 0) {
  # There are recent issues
  data.frame(
    Status = paste0(issues$recent_count, " issue(s) reported in past 14 days"),
    Action = sheet_url
  ) |>
    tinytable::tt() |>
    tinytable::format_tt(
      j = "Action",
      fn = function(x) paste0('<a href="', x, '" target="_blank">Go to Issues Form</a>')
    )
} else {
  # No recent issues
  data.frame(
    Message = "No issues reported in the past 14 days",
    Action = sheet_url
  ) |>
    tinytable::tt() |>
    tinytable::format_tt(
      j = "Action",
      fn = function(x) paste0('<a href="', x, '" target="_blank">Check Issues Form</a>')
    )
}
```
:::

### Enrollment

#### Column {width=50%}

::: {.card title="Weekly Screening Statistics"}

```{r}
# Get weekly screening statistics
weekly_stats <- tryCatch({
  token <- Sys.getenv("REDCAP_API_TOKEN")

  if (token == "" || is.na(token)) {
    # Show message when REDCap not configured
    data.frame(
      Metric = c("Total Screenings", "Eligible Participants", "Eligible Hispanic Participants", "Weekly Target", "vs Target"),
      Count = c("N/A", "N/A", "N/A", "N/A", "N/A"),
      stringsAsFactors = FALSE
    )
  } else {
    # Get actual weekly stats
    stats <- abmdash::get_weekly_screening_stats()

    # Get enrollment targets to find current month's target
    enrollment_data <- abmdash::get_enrollment_targets()

    # Get current month and year
    current_date <- format(Sys.Date(), "1-%b-%y")

    # Find current month's target
    current_month_row <- enrollment_data[enrollment_data$Date == current_date, ]

    if (nrow(current_month_row) > 0) {
      monthly_target <- as.numeric(current_month_row$Target)
      weekly_target <- ceiling(monthly_target / 4)
      difference <- stats$eligible_count - weekly_target
      vs_target <- ifelse(difference >= 0,
                         paste0("+", difference),
                         as.character(difference))
    } else {
      weekly_target <- "N/A"
      vs_target <- "N/A"
    }

    data.frame(
      Metric = c("Total Screenings (Past 7 Days)", "Eligible Participants", "Eligible Hispanic Participants", "Weekly Target (Monthly/4)", "vs Target"),
      Count = c(stats$total_screenings, stats$eligible_count, stats$hispanic_count, weekly_target, vs_target),
      stringsAsFactors = FALSE
    )
  }
}, error = function(e) {
  data.frame(
    Metric = "Error",
    Count = paste("Error:", substr(e$message, 1, 30)),
    stringsAsFactors = FALSE
  )
})

# Display the weekly statistics
weekly_stats |>
  tinytable::tt(caption = "Screening Summary (Past 7 Days)")
```

:::

::: {.card title="Total Enrollment Progress"}

```{r}
#| output: asis
# Get enrollment statistics
enrollment_stats <- tryCatch({
  abmdash::get_enrollment_stats()
}, error = function(e) {
  list(
    total_enrolled = 0,
    weekly_enrolled = 0,
    current_month = format(Sys.Date(), "%B %Y"),
    error = e$message
  )
})

# Get current month's targets from enrollment_targets.csv
current_date <- format(Sys.Date(), "1-%b-%y")
enrollment_targets <- abmdash::get_enrollment_targets()

# Find the target for the current month
current_month_target <- enrollment_targets[enrollment_targets$Date == current_date, ]

if (nrow(current_month_target) > 0) {
  monthly_target <- as.numeric(current_month_target$Target)
  total_target <- as.numeric(current_month_target$Total)
} else {
  # If no exact match, find the most recent target
  enrollment_targets$parsed_date <- as.Date(paste0("01-", enrollment_targets$Date), format = "%d-%d-%b-%y")
  past_targets <- enrollment_targets[enrollment_targets$parsed_date <= Sys.Date(), ]
  if (nrow(past_targets) > 0) {
    last_row <- past_targets[nrow(past_targets), ]
    monthly_target <- as.numeric(last_row$Target)
    total_target <- as.numeric(last_row$Total)
  } else {
    monthly_target <- 15
    total_target <- 600
  }
}

# Calculate weekly target (monthly / 4, rounded up)
weekly_target <- ceiling(monthly_target / 4)

# Calculate percentages
total_pct <- if (total_target > 0) min(round((enrollment_stats$total_enrolled / total_target) * 100, 1), 100) else 0
weekly_pct <- if (weekly_target > 0) min(round((enrollment_stats$weekly_enrolled / weekly_target) * 100, 1), 100) else 0

# Determine color based on percentage
total_color <- if (total_pct >= 80) "#2E7D32" else if (total_pct >= 50) "#F57C00" else "#C62828"

# Create HTML progress bar for total enrollment
cat(paste0(
  '<div style="text-align: center; padding: 20px;">',
  '<div style="font-size: 48px; font-weight: bold; color: ', total_color, ';">',
  enrollment_stats$total_enrolled, ' / ', total_target,
  '</div>',
  '<div style="font-size: 18px; margin: 10px 0; color: #666;">',
  'Total Enrolled (', total_pct, '%)',
  '</div>',
  '<div style="background-color: #e0e0e0; border-radius: 10px; height: 30px; margin: 20px 0; overflow: hidden;">',
  '<div style="background-color: ', total_color, '; height: 100%; width: ', total_pct, '%; transition: width 0.3s;"></div>',
  '</div>',
  '<div style="font-size: 14px; color: #999;">',
  ifelse(enrollment_stats$total_enrolled >= total_target,
         '✓ Goal Reached!',
         paste0('Need ', total_target - enrollment_stats$total_enrolled, ' more to reach goal')),
  '</div>',
  '</div>'
))
```

:::

#### Column {width=50%}

::: {.card title="Weekly Enrollment (Past 7 Days)"}

```{r}
#| output: asis
# Determine color based on percentage
weekly_color <- if (weekly_pct >= 80) "#1976D2" else if (weekly_pct >= 50) "#F57C00" else "#C62828"

# Create HTML progress bar for weekly enrollment
cat(paste0(
  '<div style="text-align: center; padding: 20px;">',
  '<div style="font-size: 48px; font-weight: bold; color: ', weekly_color, ';">',
  enrollment_stats$weekly_enrolled, ' / ', weekly_target,
  '</div>',
  '<div style="font-size: 18px; margin: 10px 0; color: #666;">',
  'Past 7 Days (', weekly_pct, '%)',
  '</div>',
  '<div style="background-color: #e0e0e0; border-radius: 10px; height: 30px; margin: 20px 0; overflow: hidden;">',
  '<div style="background-color: ', weekly_color, '; height: 100%; width: ', weekly_pct, '%; transition: width 0.3s;"></div>',
  '</div>',
  '<div style="font-size: 14px; color: #999;">',
  'Weekly target: ', monthly_target, ' ÷ 4 = ', weekly_target, ' participants<br>',
  ifelse(enrollment_stats$weekly_enrolled >= weekly_target,
         '✓ Weekly Goal Reached!',
         paste0('Need ', weekly_target - enrollment_stats$weekly_enrolled, ' more this week')),
  '</div>',
  '</div>'
))
```

:::

::: {.card title="Monthly Enrollment vs Targets"}

```{r}
# Get enrollment targets data
enrollment_data <- tryCatch({
  abmdash::get_enrollment_targets()
}, error = function(e) {
  data.frame(
    Error = paste("Could not load enrollment data:", e$message),
    stringsAsFactors = FALSE
  )
})

# Combine enrollment breakdown with targets
if (!is.null(enrollment_stats$monthly_breakdown) && nrow(enrollment_stats$monthly_breakdown) > 0 &&
    "Date" %in% names(enrollment_data)) {

  # Parse dates from enrollment_targets
  enrollment_data$month_key <- format(as.Date(paste0("01-", enrollment_data$Date), format = "%d-%d-%b-%y"), "%Y-%m")
  enrollment_data$month_display <- format(as.Date(paste0("01-", enrollment_data$Date), format = "%d-%d-%b-%y"), "%B %Y")

  # Merge actual enrollments with targets
  merged_data <- merge(
    enrollment_data[, c("month_key", "month_display", "Target")],
    enrollment_stats$monthly_breakdown,
    by.x = "month_key",
    by.y = "month",
    all.x = TRUE
  )

  # Replace NA with 0 for months with no enrollments
  merged_data$count[is.na(merged_data$count)] <- 0

  # Calculate percentage
  merged_data$percentage <- ifelse(
    merged_data$Target > 0,
    round((merged_data$count / merged_data$Target) * 100, 1),
    0
  )

  # Filter to only show months up to current month (no future months)
  current_month_key <- format(Sys.Date(), "%Y-%m")
  merged_data <- merged_data[merged_data$month_key <= current_month_key, ]

  # Sort by date descending (most recent first)
  sort_order <- order(merged_data$month_key, decreasing = TRUE)
  merged_data <- merged_data[sort_order, ]

  # Create display table from sorted data
  display_table <- data.frame(
    Month = merged_data$month_display,
    Target = merged_data$Target,
    Actual = merged_data$count,
    Percent = paste0(merged_data$percentage, "%"),
    stringsAsFactors = FALSE
  )

  # Create table with conditional formatting
  tt_table <- display_table |>
    tinytable::tt(caption = "Monthly Enrollment Progress")

  # Highlight rows where percentage >= 80% (green)
  success_rows <- which(merged_data$percentage >= 80)
  if (length(success_rows) > 0) {
    tt_table <- tt_table |>
      tinytable::style_tt(i = success_rows, background = "#e8f5e9")
  }

  # Highlight rows where percentage < 50% and target > 0 (red)
  warning_rows <- which(merged_data$percentage < 50 & merged_data$Target > 0)
  if (length(warning_rows) > 0) {
    tt_table <- tt_table |>
      tinytable::style_tt(i = warning_rows, background = "#ffebee")
  }

  tt_table

} else {
  # Fallback: just show targets if no enrollment breakdown available
  enrollment_data |>
    tinytable::tt(caption = "Monthly Enrollment Targets")
}
```
:::

### Compliance (Do NOT Open to Remain Masked)

#### Column

::: {.card title="Gamified ABM Compliance"}

```{r}
# Get gamified ABM compliance
gabm_compliance <- tryCatch({
  gabm_sheet_url <- "https://docs.google.com/spreadsheets/d/1Sz3BOKVIx4TQbMfRpgYIc_Cyt-p5dU1S1DKGr-yaLmk/edit?gid=0#gid=0"

  # Get the compliance data
  result <- abmdash::get_participant_summary(gabm_sheet_url)

  # Filter to active participants only
  active <- result[result$current_week <= 4, ]

  if (nrow(active) > 0) {
    # Calculate expected sessions based on time
    active$expected <- pmin(round(active$weeks_from_start * 4), 16)

    # Determine status
    active$status <- ifelse(
      active$sessions_behind > 0,
      paste("Behind by", round(active$sessions_behind)),
      "On Track"
    )

    # Create display data
    display_data <- data.frame(
      "Participant ID" = active$id,
      "Week" = active$current_week,
      "Sessions Completed" = active$total_sessions_completed,
      "Expected Sessions" = active$expected,
      "Status" = active$status,
      stringsAsFactors = FALSE,
      check.names = FALSE
    )

    # Create table with highlighting
    tt_table <- display_data |>
      tinytable::tt(caption = "Active Participants")

    # Highlight rows that are behind
    behind_rows <- which(active$sessions_behind > 0)
    if (length(behind_rows) > 0) {
      tt_table <- tt_table |>
        tinytable::style_tt(i = behind_rows, background = "#ffebee")
    }

    tt_table
  } else {
    data.frame(Message = "No active participants") |>
      tinytable::tt()
  }
}, error = function(e) {
  data.frame(
    Message = paste("Error loading GABM data:", substr(e$message, 1, 50))
  ) |>
    tinytable::tt()
})

gabm_compliance
```

:::

::: {.card title="Traditional ABM Compliance"}

```{r}
# Get traditional ABM compliance
trad_compliance <- tryCatch({
  # Initialize diagnostics environment (visible to error handler)
  diagnostics <- new.env()
  diagnostics$stage <- "initialization"

  # Download traditional ABM data from ABS portal
  abs_username <- Sys.getenv("ABS_USERNAME")
  abs_password <- Sys.getenv("ABS_PASSWORD")

  if (abs_username == "" || is.na(abs_username) || abs_password == "" || is.na(abs_password)) {
    data.frame(
      Message = "ABS credentials not configured (ABS_USERNAME or ABS_PASSWORD missing)"
    ) |> tinytable::tt()
  } else {
    # Login and download data with detailed diagnostics
    diagnostics$stage <- "attempting login"

    # Try to login and capture detailed information
    # Capture console output to get cookie debug messages
    login_messages <- character()
    login_result <- tryCatch({
      session <- withCallingHandlers(
        abmdash::abs_login(check_connection = FALSE),
        message = function(m) {
          login_messages <<- c(login_messages, conditionMessage(m))
        }
      )
      list(success = TRUE, session = session, error = NULL, messages = login_messages)
    }, error = function(e) {
      list(success = FALSE, session = NULL, error = as.character(e$message), messages = login_messages)
    })

    diagnostics$login_success <- login_result$success
    diagnostics$login_error <- if (!is.null(login_result$error)) substr(login_result$error, 1, 200) else "none"
    diagnostics$login_messages <- if (!is.null(login_result$messages)) paste(login_result$messages, collapse = " | ") else "none"

    # Check if cookie file exists and has content
    cookie_path <- file.path(tempdir(), "abs_session_cookies.txt")
    diagnostics$cookie_file_exists <- file.exists(cookie_path)
    diagnostics$cookie_file_size <- if (file.exists(cookie_path)) file.size(cookie_path) else 0

    # Read cookie file contents
    if (file.exists(cookie_path)) {
      cookie_contents <- readLines(cookie_path, warn = FALSE)
      diagnostics$cookie_file_preview <- substr(paste(cookie_contents, collapse = " | "), 1, 300)
      # Count actual cookie lines (non-comment, non-empty)
      cookie_lines <- cookie_contents[!grepl("^#|^\\s*$", cookie_contents)]
      diagnostics$cookie_file_num_cookies <- length(cookie_lines)
      diagnostics$cookie_file_has_beevers <- any(grepl("beevers_session", cookie_contents))
    } else {
      diagnostics$cookie_file_preview <- "file not found"
      diagnostics$cookie_file_num_cookies <- 0
      diagnostics$cookie_file_has_beevers <- FALSE
    }

    if (!login_result$success) {
      stop("Login failed: ", login_result$error)
    }

    diagnostics$stage <- "downloading CSV"
    session <- login_result$session
    diagnostics$session_class <- class(session)[1]

    # DEFINITIVE TEST: Make request to abs.la.utexas.edu to see if cookies are sent
    # (httpbin.org won't work - different domain!)
    test_req <- session |>
      httr2::req_url("https://abs.la.utexas.edu/admin/dashboard") |>
      httr2::req_error(is_error = function(resp) FALSE) |>
      httr2::req_perform()

    test_status <- httr2::resp_status(test_req)
    test_content_type <- httr2::resp_header(test_req, "content-type") %||% "unknown"
    # If we're authenticated, we should get HTML dashboard (200)
    # If not authenticated, we get redirected to login (302) or login page HTML
    diagnostics$test_request_status <- test_status
    diagnostics$test_request_authenticated <- (test_status == 200 && grepl("html", test_content_type, ignore.case = TRUE))

    # Check if session has extracted cookies attribute
    session_cookies <- attr(session, "session_cookies")
    diagnostics$has_cookies_attr <- !is.null(session_cookies)
    diagnostics$cookies_attr_length <- if (!is.null(session_cookies)) length(session_cookies) else 0
    diagnostics$cookies_attr_class <- if (!is.null(session_cookies)) class(session_cookies)[1] else "NULL"
    diagnostics$cookies_attr_names <- if (!is.null(session_cookies)) paste(names(session_cookies), collapse = ", ") else "none"
    # Show raw content of each cookie (first 100 chars each)
    if (!is.null(session_cookies) && length(session_cookies) > 0) {
      cookie_previews <- sapply(seq_along(session_cookies), function(i) {
        paste0("Cookie", i, ":", substr(session_cookies[[i]], 1, 100))
      })
      diagnostics$cookies_raw_content <- paste(cookie_previews, collapse = " || ")
    } else {
      diagnostics$cookies_raw_content <- "none"
    }

    # Manually parse cookie file (including #HttpOnly_ lines)
    cookie_file_path <- file.path(tempdir(), "abs_session_cookies.txt")
    cookie_pairs <- character()

    if (file.exists(cookie_file_path)) {
      cookie_lines <- readLines(cookie_file_path, warn = FALSE)

      for (line in cookie_lines) {
        original_line <- line

        # Handle #HttpOnly_ prefix (special Netscape format for HttpOnly cookies)
        if (grepl("^#HttpOnly_", line)) {
          line <- sub("^#HttpOnly_", "", line)
        } else if (grepl("^#", line) || grepl("^\\s*$", line)) {
          # Skip actual comments and empty lines
          next
        }

        # Parse Netscape cookie file format (tab-separated)
        # Format: domain \t flag \t path \t secure \t expiration \t name \t value
        parts <- strsplit(line, "\\t")[[1]]

        if (length(parts) >= 7) {
          cookie_name <- parts[6]
          cookie_value <- parts[7]
          cookie_pairs <- c(cookie_pairs, paste0(cookie_name, "=", cookie_value))
        }
      }
    }

    cookie_string <- paste(cookie_pairs, collapse="; ")
    diagnostics$cookie_preview <- substr(cookie_string, 1, 300)
    diagnostics$cookies_parsed_from_file <- length(cookie_pairs)

    # Make request with manually constructed Cookie header
    req <- session |>
      httr2::req_url_path("/admin/test/download-csv-all") |>
      httr2::req_headers(Cookie = cookie_string) |>
      httr2::req_options(http_version = 0)

    # Perform request
    response <- req |>
      httr2::req_error(is_error = function(resp) FALSE) |>
      httr2::req_perform()

      # Capture response details
      diagnostics$csv_status <- httr2::resp_status(response)
      diagnostics$csv_content_type <- httr2::resp_header(response, "content-type") %||% "unknown"
      body <- httr2::resp_body_string(response)
      diagnostics$csv_body_length <- nchar(body)
      diagnostics$csv_body_preview <- substr(body, 1, 500)

      # Try to extract HTML title if it's HTML
      if (grepl("text/html", diagnostics$csv_content_type, ignore.case = TRUE)) {
        title_match <- regmatches(body, regexpr("<title>([^<]*)</title>", body, ignore.case = TRUE))
        diagnostics$html_title <- if (length(title_match) > 0) gsub("</?title>", "", title_match[1], ignore.case = TRUE) else "no title found"
      }

      if (httr2::resp_status(response) == 200) {
        trad_data <- utils::read.csv(text = body, stringsAsFactors = FALSE)
      } else {
        stop("CSV request failed with status: ", httr2::resp_status(response))
      }
    } else {
      # Fall back to package function
      diagnostics$cookie_preview <- "none"
      trad_data <- abmdash::download_abs_csv(session, csv_path = "/admin/test/download-csv-all")
    }

    # Store diagnostics
    diagnostics$raw_rows <- nrow(trad_data)
    diagnostics$raw_cols <- paste(names(trad_data), collapse = ", ")
    diagnostics$has_start_time <- "start_time" %in% names(trad_data)

    if ("start_time" %in% names(trad_data)) {
      diagnostics$start_time_class <- class(trad_data$start_time)[1]
      diagnostics$start_time_sample <- paste(head(trad_data$start_time, 2), collapse = " | ")
      diagnostics$start_time_length <- length(trad_data$start_time)
    }

    # Process the data
    diagnostics$stage <- "processing timestamps"
    trad_data$start_time <- as.POSIXct(trad_data$start_time, tz = "UTC")

    # Filter out test IDs
    diagnostics$stage <- "filtering test IDs"
    is_test <- grepl("test", trad_data$subject_id, ignore.case = TRUE)
    trad_data <- trad_data[!is_test, ]
    diagnostics$filtered_rows <- nrow(trad_data)

    # Get first session date per participant
    diagnostics$stage <- "extracting session 1 data"
    session_1_data <- trad_data[trad_data$session == 1, ]
    diagnostics$session1_rows <- nrow(session_1_data)

    diagnostics$stage <- "aggregating first sessions"
    first_sessions <- aggregate(start_time ~ subject_id,
                               data = session_1_data,
                               FUN = min)
    diagnostics$first_sessions_rows <- nrow(first_sessions)
    names(first_sessions) <- c("id", "start_date")

    # Calculate weeks from start
    diagnostics$stage <- "calculating weeks from start"
    first_sessions$weeks_from_start <- as.numeric(
      difftime(Sys.time(), first_sessions$start_date, units = "weeks")
    )

    # Filter to active participants (within 5 weeks)
    diagnostics$stage <- "filtering to active participants"
    active <- first_sessions[first_sessions$weeks_from_start <= 5, ]
    diagnostics$active_rows <- nrow(active)

    if (nrow(active) > 0) {
      # Count sessions per participant
      diagnostics$stage <- "counting sessions per participant"
      session_counts <- aggregate(session ~ subject_id,
                                 data = trad_data,
                                 FUN = length)
      diagnostics$session_counts_rows <- nrow(session_counts)

      names(session_counts) <- c("id", "total_sessions")

      # Merge - use safer approach
      diagnostics$stage <- "merging active with session_counts"
      if (nrow(session_counts) > 0) {
        # Capture ID information for debugging
        active_ids <- active$id
        session_ids <- session_counts$id
        diagnostics$active_ids_sample <- paste(head(active_ids, 3), collapse = ", ")
        diagnostics$session_ids_sample <- paste(head(session_ids, 3), collapse = ", ")
        diagnostics$ids_overlap <- sum(active_ids %in% session_ids)

        active_merged <- merge(active, session_counts, by = "id", all.x = TRUE)
        diagnostics$merged_rows <- nrow(active_merged)

        # Replace NA with 0
        if ("total_sessions" %in% names(active_merged)) {
          diagnostics$na_count <- sum(is.na(active_merged$total_sessions))
          active_merged$total_sessions[is.na(active_merged$total_sessions)] <- 0
        } else {
          active_merged$total_sessions <- 0
        }
        active <- active_merged
      } else {
        # No sessions found - add total_sessions column with 0
        active$total_sessions <- 0
      }

      # Calculate expected and status
      diagnostics$stage <- "calculating expected sessions and status"
      active$current_week <- pmin(ceiling(active$weeks_from_start), 4)
      active$expected <- pmin(round(active$weeks_from_start * 4), 16)
      active$behind <- active$expected - active$total_sessions

      active$status <- ifelse(
        active$behind > 0,
        paste("Behind by", round(active$behind)),
        "On Track"
      )

      # Create display data
      diagnostics$stage <- "creating display data"
      display_data <- data.frame(
        "Participant ID" = active$id,
        "Week" = active$current_week,
        "Sessions Completed" = active$total_sessions,
        "Expected Sessions" = active$expected,
        "Status" = active$status,
        stringsAsFactors = FALSE,
        check.names = FALSE
      )

      # Create table with highlighting
      diagnostics$stage <- "creating table"
      tt_table <- display_data |>
        tinytable::tt(caption = "Active Participants")

      # Highlight rows that are behind
      behind_rows <- which(active$behind > 0)
      if (length(behind_rows) > 0) {
        tt_table <- tt_table |>
          tinytable::style_tt(i = behind_rows, background = "#ffebee")
      }

      tt_table
    } else {
      data.frame(Message = "No active participants") |>
        tinytable::tt()
    }
  }
}, error = function(e) {
  # Display error with all diagnostic information
  if (exists("diagnostics") && is.environment(diagnostics)) {
    # Build comprehensive diagnostic output
    diag_parts <- list(
      data.frame(Info = "Stage", Value = diagnostics$stage %||% "unknown", stringsAsFactors = FALSE)
    )

    # Login diagnostics
    if (!is.null(diagnostics$login_success)) {
      diag_parts <- append(diag_parts, list(
        data.frame(Info = "Login Success", Value = as.character(diagnostics$login_success), stringsAsFactors = FALSE),
        data.frame(Info = "Login Error", Value = diagnostics$login_error %||% "none", stringsAsFactors = FALSE),
        data.frame(Info = "Login Messages", Value = substr(diagnostics$login_messages %||% "none", 1, 500), stringsAsFactors = FALSE),
        data.frame(Info = "Cookie File Exists", Value = as.character(diagnostics$cookie_file_exists %||% FALSE), stringsAsFactors = FALSE),
        data.frame(Info = "Cookie File Size", Value = as.character(diagnostics$cookie_file_size %||% 0), stringsAsFactors = FALSE),
        data.frame(Info = "Cookie File Num Cookies", Value = as.character(diagnostics$cookie_file_num_cookies %||% 0), stringsAsFactors = FALSE),
        data.frame(Info = "Cookie File Has Beevers", Value = as.character(diagnostics$cookie_file_has_beevers %||% FALSE), stringsAsFactors = FALSE),
        data.frame(Info = "Cookie File Preview", Value = substr(diagnostics$cookie_file_preview %||% "none", 1, 500), stringsAsFactors = FALSE),
        data.frame(Info = "Cookies Parsed From File", Value = as.character(diagnostics$cookies_parsed_from_file %||% 0), stringsAsFactors = FALSE)
      ))
    }

    # Session diagnostics
    if (!is.null(diagnostics$session_class)) {
      diag_parts <- append(diag_parts, list(
        data.frame(Info = "Session Class", Value = diagnostics$session_class %||% "unknown", stringsAsFactors = FALSE),
        data.frame(Info = "Test Request Status", Value = as.character(diagnostics$test_request_status %||% "unknown"), stringsAsFactors = FALSE),
        data.frame(Info = "Test Request Authenticated", Value = as.character(diagnostics$test_request_authenticated %||% FALSE), stringsAsFactors = FALSE),
        data.frame(Info = "Has Cookies Attr", Value = as.character(diagnostics$has_cookies_attr %||% FALSE), stringsAsFactors = FALSE),
        data.frame(Info = "Cookies Attr Length", Value = as.character(diagnostics$cookies_attr_length %||% 0), stringsAsFactors = FALSE),
        data.frame(Info = "Cookies Attr Class", Value = diagnostics$cookies_attr_class %||% "unknown", stringsAsFactors = FALSE),
        data.frame(Info = "Cookies Attr Names", Value = diagnostics$cookies_attr_names %||% "none", stringsAsFactors = FALSE),
        data.frame(Info = "Cookies Raw Content", Value = substr(diagnostics$cookies_raw_content %||% "none", 1, 500), stringsAsFactors = FALSE),
        data.frame(Info = "Cookie Preview", Value = diagnostics$cookie_preview %||% "none", stringsAsFactors = FALSE)
      ))
    }

    # CSV download diagnostics
    if (!is.null(diagnostics$csv_status)) {
      diag_parts <- append(diag_parts, list(
        data.frame(Info = "CSV Status", Value = as.character(diagnostics$csv_status), stringsAsFactors = FALSE),
        data.frame(Info = "CSV Error", Value = substr(diagnostics$csv_error %||% "none", 1, 300), stringsAsFactors = FALSE),
        data.frame(Info = "Content-Type", Value = diagnostics$csv_content_type %||% "unknown", stringsAsFactors = FALSE),
        data.frame(Info = "Body Length", Value = as.character(diagnostics$csv_body_length %||% 0), stringsAsFactors = FALSE),
        data.frame(Info = "HTML Title", Value = substr(diagnostics$html_title %||% "N/A", 1, 200), stringsAsFactors = FALSE),
        data.frame(Info = "Body Preview", Value = substr(diagnostics$csv_body_preview %||% "none", 1, 500), stringsAsFactors = FALSE)
      ))
    }

    # Data processing diagnostics
    if (!is.null(diagnostics$raw_rows)) {
      diag_parts <- append(diag_parts, list(
        data.frame(Info = "Parsed Rows", Value = as.character(diagnostics$raw_rows), stringsAsFactors = FALSE),
        data.frame(Info = "Columns", Value = substr(diagnostics$raw_cols %||% "N/A", 1, 200), stringsAsFactors = FALSE)
      ))
    }

    # Combine all diagnostics
    diag_df <- do.call(rbind, diag_parts)
    diag_df <- rbind(
      data.frame(Info = "Error Message", Value = substr(as.character(e$message), 1, 500), stringsAsFactors = FALSE),
      diag_df
    )

    diag_df |> tinytable::tt()
  } else {
    data.frame(
      Info = "Error",
      Value = substr(as.character(e$message), 1, 500),
      stringsAsFactors = FALSE
    ) |>
      tinytable::tt()
  }
})

trad_compliance
```

:::
